---
title: "ARD-first tables using {cards}"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ARD-first tables using {cards}}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(tfrmt)
library(cards)
```

Preparing analysis results in a tidy ARD format is a prerequisite for a {tfrmt} table. A useful tool for ARD creation is the [{cards}](https://insightsengineering.github.io/cards/latest-tag/) package. By design, the output of {cards} is display-agnostic and only contains information about the summaries themselves. Thus, the output requires a bit of manipulation to get the ARD in a display-ready format. For example, a `cards` object will label all denominators as "N", but {tfrmt} expects header (i.e. population-level) big Ns to have a unique label that sets them apart from other denominators, like "bigN". 

{tfrmt} contains several helper functions to ease the transition from the `cards` output to a display-ready ARD fit for {tfrmt}. Below are two examples utilizing these helpers for a demographics and AE table. 

## Demog table

Demographics tables commonly contain a mix of categorical and continuous summaries by treatment group. We can perform these summaries using the following {cards} code:

```{r}
ard_demog <- ard_stack(
  data = pharmaverseadam::adsl |> dplyr::filter(SAFFL == "Y"),
  ard_categorical(
    variables = "AGEGR1",
    statistic = ~ c("p")
  ),
  ard_continuous(
    variables = "AGE",
    statistic = ~ continuous_summary_fns(c("mean", "sd"))
  ),
  .by = "ARM"
)

ard_demog
```

The first step in preparing the data for {tfrmt} is calling `shuffle_card()` which performs general operations to get the results in a tidy data frame without list-columns and extra metadata. 

```{r}
ard_demog_shuffled <- ard_demog |>
  shuffle_card()

ard_demog_shuffled
```

Note that the variables have been transformed wide and renamed. NULL values have also been filled with "Overall <colname>".

For our {tfrmt} table, `AGEGR1` and `AGE` need to be combined into a single variable. We can use the `prep_combine_vars()` helper for this:

```{r}
ard_demog_shuffled <- ard_demog_shuffled |>
  prep_combine_vars(vars = c("AGEGR1", "AGE"))

ard_demog_shuffled
```

Next, we want to make a row label column that is the variable level for categorical `AGEGR1` and the stat label for continuous `AGE`. We can use the `prep_label()` helper for this:

```{r}
ard_demog_shuffled <- ard_demog_shuffled |>
  prep_label()

ard_demog_shuffled
```

Note that if we take a peek at our stats for the treatment groups, we have `n`, `N`, `p` from the `ard_stack()` call: 

```{r}
tail(ard_demog_shuffled)
```

Commonly we only want to display the `n` in the column headers for treatment group. To distinguish these as big N's, we need to relabel the stat, and drop the unnecessary `N` and `p`. The `prep_big_n()` helper takes care of this for us:

```{r}
ard_demog_shuffled <- ard_demog_shuffled |>
  prep_big_n(vars = "ARM") # the grouping variable we want to prepare big N's for

ard_demog_shuffled
```

Finally, we can do any additional table-specific manipulations and we're ready for our tfrmt!
```{r}
ard_final <- ard_demog_shuffled |>
  # drop unneeded variables
  dplyr::select(-c(variable_level, context, stat_label)) |>
  # add sorting
  dplyr::mutate(ord1 = dplyr::case_when(
    label == "18-64" ~ 1,
    label == ">64" ~ 2,
    TRUE ~ 3
  ))

ard_final
```

Create the {tfrmt}
```{r}
tfrmt(
  group = stat_variable,
  label = label,
  param = stat_name,
  value = stat,
  column = ARM,
  sorting_cols = ord1,
  body_plan = body_plan(
    frmt_structure(
      group_val = ".default",
      label_val = ".default",
      frmt("xx.x")
    ),
    frmt_structure(
      group_val = ".default",
      label_val = ".default",
      p = frmt("xx%", transform = ~ . * 100)
    )
  ),
  big_n = big_n_structure(param_val = "bigN"),
  col_plan = col_plan(-ord1)
) |>
  print_to_gt(ard_final)
```



## AE table

AE tables contain hierarchical summaries. We can perform these summaries using the following {cards} code:

```{r}
adae <- pharmaverseadam::adae |>
  dplyr::filter(SAFFL == "Y") |>
  dplyr::filter(AESOC %in% unique(AESOC)[1:2]) |>
  dplyr::group_by(AESOC) |>
  dplyr::filter(AEDECOD %in% unique(AEDECOD)[1:3]) |>
  dplyr::ungroup()

ard_ae <- ard_stack_hierarchical(
  data = adae,
  variables = c(AESOC, AEDECOD),
  by = ARM,
  denominator = pharmaverseadam::adsl |> dplyr::filter(SAFFL == "Y"),
  id = USUBJID,
  statistic = ~ c("n", "p")
)

ard_ae
```

Like the demog table example, the first step in preparing the data for {tfrmt} is calling `shuffle_card()` which performs general operations to get the results in a tidy data frame without list-columns and extra metadata. 

```{r}
ard_ae_shuffled <- ard_ae |>
  shuffle_card()

ard_ae_shuffled
```

Notice that our calculations of any AE by system organ class (AESOC) have a missing value for preferred term (AEDECOD):

```{r}
ard_ae_shuffled |>
  dplyr::filter(!is.na(AESOC) & is.na(AEDECOD))
```

We need to populate these missing values for our table. In order to display these as group summaries, the value for AEDECOD must match the value for AESOC. We can use the `prep_hierarchical_fill()` helper to fill the value from AESOC into AEDECOD:

```{r}
ard_ae_shuffled <- ard_ae_shuffled |>
  prep_hierarchical_fill(
    vars = c("AESOC", "AEDECOD"),
    fill_from_left = TRUE
  )

ard_ae_shuffled |>
  dplyr::filter(AESOC == AEDECOD)
```



Note that if we take a peek at our stats for the treatment groups, we have `n`, `N`, `p` from the `ard_stack()` call: 

```{r}
ard_ae_shuffled |>
  dplyr::filter(is.na(AESOC))
```

Commonly we only want to display the `n` in the column headers for treatment group. To distinguish these as big N's, we need to relabel the stat, and drop the unnecessary `N` and `p`. The `prep_big_n()` helper takes care of this for us:

```{r}
ard_ae_shuffled <- ard_ae_shuffled |>
  prep_big_n(vars = "ARM") # the grouping variable we want to prepare big N's for

ard_ae_shuffled
```

Finally, we can do any additional table-specific manipulations and we're ready for our tfrmt!
```{r}
ard_final <- ard_ae_shuffled |>
  # drop uneeded variables
  dplyr::select(-c(context, stat_label, stat_variable))

ard_final
```

Create the {tfrmt}
```{r}
tfrmt(
  group = AESOC,
  label = AEDECOD,
  param = stat_name,
  value = stat,
  column = ARM,
  body_plan = body_plan(
    frmt_structure(
      group_val = ".default",
      label_val = ".default",
      frmt_combine(
        "{n} ({p}%)",
        n = frmt("xx"),
        p = frmt("xx", transform = ~ . * 100)
      )
    )
  ),
  big_n = big_n_structure(
    param_val = "bigN"
  )
) |>
  print_to_gt(ard_final)
```
